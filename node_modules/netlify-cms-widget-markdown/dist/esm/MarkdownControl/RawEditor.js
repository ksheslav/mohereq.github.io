"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _styledBase = _interopRequireDefault(require("@emotion/styled-base"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactImmutableProptypes = _interopRequireDefault(require("react-immutable-proptypes"));

var _core = require("@emotion/core");

var _slate = require("slate");

var _slateReact = require("slate-react");

var _slatePlainSerializer = _interopRequireDefault(require("slate-plain-serializer"));

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _netlifyCmsUiDefault = require("netlify-cms-ui-default");

var _serializers = require("../serializers");

var _styles = require("../styles");

var _Toolbar = _interopRequireDefault(require("./Toolbar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n                  ", "\n                "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

const styleStrings = {
  slateRaw: "\n    position: relative;\n    overflow: hidden;\n    overflow-x: auto;\n    min-height: ".concat(_netlifyCmsUiDefault.lengths.richTextEditorMinHeight, ";\n    font-family: ").concat(_netlifyCmsUiDefault.fonts.mono, ";\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n    border-top: 0;\n    margin-top: -").concat(_styles.editorStyleVars.stickyDistanceBottom, ";\n  ")
};
const RawEditorContainer = (0, _styledBase.default)("div", {
  target: "er7tv020",
  label: "RawEditorContainer"
})(process.env.NODE_ENV === "production" ? {
  name: "79elbk",
  styles: "position:relative;"
} : {
  name: "79elbk",
  styles: "position:relative;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9NYXJrZG93bkNvbnRyb2wvUmF3RWRpdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZCcUMiLCJmaWxlIjoiLi4vLi4vLi4vc3JjL01hcmtkb3duQ29udHJvbC9SYXdFZGl0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBJbW11dGFibGVQcm9wVHlwZXMgZnJvbSAncmVhY3QtaW1tdXRhYmxlLXByb3B0eXBlcyc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBDbGFzc05hbWVzIH0gZnJvbSAnQGVtb3Rpb24vY29yZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IEVkaXRvciBhcyBTbGF0ZSwgc2V0RXZlbnRUcmFuc2ZlciB9IGZyb20gJ3NsYXRlLXJlYWN0JztcbmltcG9ydCBQbGFpbiBmcm9tICdzbGF0ZS1wbGFpbi1zZXJpYWxpemVyJztcbmltcG9ydCBpc0hvdGtleSBmcm9tICdpcy1ob3RrZXknO1xuaW1wb3J0IHsgbGVuZ3RocywgZm9udHMgfSBmcm9tICduZXRsaWZ5LWNtcy11aS1kZWZhdWx0JztcbmltcG9ydCB7IG1hcmtkb3duVG9IdG1sIH0gZnJvbSAnLi4vc2VyaWFsaXplcnMnO1xuaW1wb3J0IHsgZWRpdG9yU3R5bGVWYXJzLCBFZGl0b3JDb250cm9sQmFyIH0gZnJvbSAnLi4vc3R5bGVzJztcbmltcG9ydCBUb29sYmFyIGZyb20gJy4vVG9vbGJhcic7XG5cbmNvbnN0IHN0eWxlU3RyaW5ncyA9IHtcbiAgc2xhdGVSYXc6IGBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgIG1pbi1oZWlnaHQ6ICR7bGVuZ3Rocy5yaWNoVGV4dEVkaXRvck1pbkhlaWdodH07XG4gICAgZm9udC1mYW1pbHk6ICR7Zm9udHMubW9ub307XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcbiAgICBib3JkZXItdG9wOiAwO1xuICAgIG1hcmdpbi10b3A6IC0ke2VkaXRvclN0eWxlVmFycy5zdGlja3lEaXN0YW5jZUJvdHRvbX07XG4gIGAsXG59O1xuXG5jb25zdCBSYXdFZGl0b3JDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XG5gO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYXdFZGl0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IFBsYWluLmRlc2VyaWFsaXplKHRoaXMucHJvcHMudmFsdWUgfHwgJycpLFxuICAgIH07XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gIXRoaXMuc3RhdGUudmFsdWUuZXF1YWxzKG5leHRTdGF0ZS52YWx1ZSk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wZW5kaW5nRm9jdXMpIHtcbiAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XG4gICAgICB0aGlzLnByb3BzLnBlbmRpbmdGb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvcHkgPSBhc3luYyAoZXZlbnQsIGVkaXRvcikgPT4ge1xuICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICBjb25zdCB7IGdldEFzc2V0LCByZXNvbHZlV2lkZ2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG1hcmtkb3duID0gUGxhaW4uc2VyaWFsaXplKFZhbHVlLmNyZWF0ZSh7IGRvY3VtZW50OiBlZGl0b3IudmFsdWUuZnJhZ21lbnQgfSkpO1xuICAgIGNvbnN0IGh0bWwgPSBhd2FpdCBtYXJrZG93blRvSHRtbChtYXJrZG93biwgeyBnZXRBc3NldCwgcmVzb2x2ZVdpZGdldCB9KTtcbiAgICBzZXRFdmVudFRyYW5zZmVyKGV2ZW50LCAndGV4dCcsIG1hcmtkb3duKTtcbiAgICBzZXRFdmVudFRyYW5zZmVyKGV2ZW50LCAnaHRtbCcsIGh0bWwpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgaGFuZGxlQ3V0ID0gYXN5bmMgKGV2ZW50LCBlZGl0b3IsIG5leHQpID0+IHtcbiAgICBhd2FpdCB0aGlzLmhhbmRsZUNvcHkoZXZlbnQsIGVkaXRvciwgbmV4dCk7XG4gICAgZWRpdG9yLmRlbGV0ZSgpO1xuICB9O1xuXG4gIGhhbmRsZVBhc3RlID0gKGV2ZW50LCBlZGl0b3IsIG5leHQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoaXNIb3RrZXkoJ3NoaWZ0JywgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gUGxhaW4uZGVzZXJpYWxpemUoZGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykpO1xuICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQodmFsdWUuZG9jdW1lbnQpO1xuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IGVkaXRvciA9PiB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnZhbHVlLmRvY3VtZW50LmVxdWFscyhlZGl0b3IudmFsdWUuZG9jdW1lbnQpKSB7XG4gICAgICB0aGlzLmhhbmRsZURvY3VtZW50Q2hhbmdlKGVkaXRvcik7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZTogZWRpdG9yLnZhbHVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBkb2N1bWVudCB2YWx1ZSBjaGFuZ2VzLCBzZXJpYWxpemUgZnJvbSBTbGF0ZSdzIEFTVCBiYWNrIHRvIHBsYWluXG4gICAqIHRleHQgKHdoaWNoIGlzIE1hcmtkb3duKSBhbmQgcGFzcyB0aGF0IHVwIGFzIHRoZSBuZXcgdmFsdWUuXG4gICAqL1xuICBoYW5kbGVEb2N1bWVudENoYW5nZSA9IGRlYm91bmNlKGVkaXRvciA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBQbGFpbi5zZXJpYWxpemUoZWRpdG9yLnZhbHVlKTtcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgfSwgMTUwKTtcblxuICBoYW5kbGVUb2dnbGVNb2RlID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25Nb2RlKCd2aXN1YWwnKTtcbiAgfTtcblxuICBwcm9jZXNzUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLmVkaXRvciA9IHJlZjtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGZpZWxkIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8UmF3RWRpdG9yQ29udGFpbmVyPlxuICAgICAgICA8RWRpdG9yQ29udHJvbEJhcj5cbiAgICAgICAgICA8VG9vbGJhclxuICAgICAgICAgICAgb25Ub2dnbGVNb2RlPXt0aGlzLmhhbmRsZVRvZ2dsZU1vZGV9XG4gICAgICAgICAgICBidXR0b25zPXtmaWVsZC5nZXQoJ2J1dHRvbnMnKX1cbiAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgICByYXdNb2RlXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JDb250cm9sQmFyPlxuICAgICAgICA8Q2xhc3NOYW1lcz5cbiAgICAgICAgICB7KHsgY3NzLCBjeCB9KSA9PiAoXG4gICAgICAgICAgICA8U2xhdGVcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgY3NzYFxuICAgICAgICAgICAgICAgICAgJHtzdHlsZVN0cmluZ3Muc2xhdGVSYXd9XG4gICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgb25QYXN0ZT17dGhpcy5oYW5kbGVQYXN0ZX1cbiAgICAgICAgICAgICAgb25DdXQ9e3RoaXMuaGFuZGxlQ3V0fVxuICAgICAgICAgICAgICBvbkNvcHk9e3RoaXMuaGFuZGxlQ29weX1cbiAgICAgICAgICAgICAgcmVmPXt0aGlzLnByb2Nlc3NSZWZ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvQ2xhc3NOYW1lcz5cbiAgICAgIDwvUmF3RWRpdG9yQ29udGFpbmVyPlxuICAgICk7XG4gIH1cbn1cblxuUmF3RWRpdG9yLnByb3BUeXBlcyA9IHtcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uTW9kZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWVsZDogSW1tdXRhYmxlUHJvcFR5cGVzLm1hcC5pc1JlcXVpcmVkLFxufTtcbiJdfQ== */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
});

class RawEditor extends _react.default.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "handleCopy", async (event, editor) => {
      event.persist();
      const {
        getAsset,
        resolveWidget
      } = this.props;

      const markdown = _slatePlainSerializer.default.serialize(_slate.Value.create({
        document: editor.value.fragment
      }));

      const html = await (0, _serializers.markdownToHtml)(markdown, {
        getAsset,
        resolveWidget
      });
      (0, _slateReact.setEventTransfer)(event, 'text', markdown);
      (0, _slateReact.setEventTransfer)(event, 'html', html);
      event.preventDefault();
    });

    _defineProperty(this, "handleCut", async (event, editor, next) => {
      await this.handleCopy(event, editor, next);
      editor.delete();
    });

    _defineProperty(this, "handlePaste", (event, editor, next) => {
      const data = event.clipboardData;

      if ((0, _isHotkey.default)('shift', event)) {
        return next();
      }

      const value = _slatePlainSerializer.default.deserialize(data.getData('text/plain'));

      return editor.insertFragment(value.document);
    });

    _defineProperty(this, "handleChange", editor => {
      if (!this.state.value.document.equals(editor.value.document)) {
        this.handleDocumentChange(editor);
      }

      this.setState({
        value: editor.value
      });
    });

    _defineProperty(this, "handleDocumentChange", (0, _debounce2.default)(editor => {
      const value = _slatePlainSerializer.default.serialize(editor.value);

      this.props.onChange(value);
    }, 150));

    _defineProperty(this, "handleToggleMode", () => {
      this.props.onMode('visual');
    });

    _defineProperty(this, "processRef", ref => {
      this.editor = ref;
    });

    this.state = {
      value: _slatePlainSerializer.default.deserialize(this.props.value || '')
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !this.state.value.equals(nextState.value);
  }

  componentDidMount() {
    if (this.props.pendingFocus) {
      this.editor.focus();
      this.props.pendingFocus();
    }
  }

  render() {
    const {
      className,
      field
    } = this.props;
    return (0, _core.jsx)(RawEditorContainer, null, (0, _core.jsx)(_styles.EditorControlBar, null, (0, _core.jsx)(_Toolbar.default, {
      onToggleMode: this.handleToggleMode,
      buttons: field.get('buttons'),
      disabled: true,
      rawMode: true
    })), (0, _core.jsx)(_core.ClassNames, null, (_ref) => {
      let {
        css,
        cx
      } = _ref;
      return (0, _core.jsx)(_slateReact.Editor, {
        className: cx(className, css(_templateObject(), styleStrings.slateRaw)),
        value: this.state.value,
        onChange: this.handleChange,
        onPaste: this.handlePaste,
        onCut: this.handleCut,
        onCopy: this.handleCopy,
        ref: this.processRef
      });
    }));
  }

}

exports.default = RawEditor;
RawEditor.propTypes = {
  onChange: _propTypes.default.func.isRequired,
  onMode: _propTypes.default.func.isRequired,
  className: _propTypes.default.string.isRequired,
  value: _propTypes.default.string,
  field: _reactImmutableProptypes.default.map.isRequired
};